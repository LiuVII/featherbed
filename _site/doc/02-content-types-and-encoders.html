<!DOCTYPE html>
<html lang="en-us">
  
  <head>
  <meta charset="UTF-8">
  <title>featherbed</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <link rel="stylesheet" href="/featherbed/css/normalize.css">
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/featherbed/css/cayman.css">
  <link rel="stylesheet" href="/featherbed/css/code.css">
</head>


  <body>
    <section class="page-header">
  <h1 class="project-name">featherbed</h1>
  <h2 class="project-tagline">Asynchronous Scala HTTP client using Finagle, Shapeless and Cats</h2>
  <a href="https://github.com/jeremyrsmith/featherbed" class="btn">View on GitHub</a>
</section>


    <section class="main-content">
      
      <h1 id="content-types-and-encoders">Content Types and Encoders</h1>

<p>In many cases, you’ll have to send content to REST services.  Most of the time, you aren’t going to want to pass a <code class="highlighter-rouge">Buf</code>
(a collection of bytes) to a REST service.  Rather, you would probably prefer to pass some representation of a request,
and featherbed is equipped to handle that.  As long as there is a <code class="highlighter-rouge">featherbed.content.Encoder[T, CT]</code> in implicit
scope, featherbed can take care of marshalling a value of type <code class="highlighter-rouge">T</code> into a representation in MIME type <code class="highlighter-rouge">CT</code>.</p>

<p>If that sounds confusing, don’t worry.  Featherbed provides modules for dealing with common content types.  If you want
to implement a content type for yourself, you can read about it later on (it’s not that hard, as long as you understand
typeclasses and singleton literals.)</p>

<p>Let’s take a look at how we might interact with a service that accepts JSON payloads.  We’ll use the provided module
<code class="highlighter-rouge">featherbed-circe</code>, which provides automatic JSON encoding and decoding using the excellent Circe library
from the Typelevel stack.</p>

<p>First, the same setup as before:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">com.twitter.util.</span><span class="o">{</span><span class="nc">Future</span><span class="o">,</span><span class="nc">Await</span><span class="o">}</span>
<span class="c1">// import com.twitter.util.{Future, Await}
</span>
<span class="k">import</span> <span class="nn">com.twitter.finagle.</span><span class="o">{</span><span class="nc">Service</span><span class="o">,</span><span class="nc">Http</span><span class="o">}</span>
<span class="c1">// import com.twitter.finagle.{Service, Http}
</span>
<span class="k">import</span> <span class="nn">com.twitter.finagle.http.</span><span class="o">{</span><span class="nc">Request</span><span class="o">,</span><span class="nc">Response</span><span class="o">}</span>
<span class="c1">// import com.twitter.finagle.http.{Request, Response}
</span>
<span class="k">import</span> <span class="nn">java.net.InetSocketAddress</span>
<span class="c1">// import java.net.InetSocketAddress
</span>
<span class="k">val</span> <span class="n">server</span> <span class="k">=</span> <span class="nc">Http</span><span class="o">.</span><span class="n">serve</span><span class="o">(</span><span class="k">new</span> <span class="nc">InetSocketAddress</span><span class="o">(</span><span class="mi">8766</span><span class="o">),</span> <span class="k">new</span> <span class="nc">Service</span><span class="o">[</span><span class="kt">Request</span>, <span class="kt">Response</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">request</span><span class="k">:</span> <span class="kt">Request</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Response</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">rep</span> <span class="k">=</span> <span class="nc">Response</span><span class="o">()</span>
    <span class="n">rep</span><span class="o">.</span><span class="n">contentString</span> <span class="k">=</span> <span class="n">s</span><span class="s">"${request.method} ${request.uri} :: ${request.contentString}"</span>
    <span class="n">rep</span>
  <span class="o">}</span>
<span class="o">})</span>
<span class="c1">// server: com.twitter.finagle.ListeningServer = Group(/0:0:0:0:0:0:0:0:8766)
</span>
<span class="k">import</span> <span class="nn">java.net.URL</span>
<span class="c1">// import java.net.URL
</span>
<span class="k">val</span> <span class="n">client</span> <span class="k">=</span> <span class="k">new</span> <span class="n">featherbed</span><span class="o">.</span><span class="nc">Client</span><span class="o">(</span><span class="k">new</span> <span class="nc">URL</span><span class="o">(</span><span class="s">"http://localhost:8766/api/"</span><span class="o">))</span>
<span class="c1">// client: featherbed.Client = featherbed.Client@f63b010
</span></code></pre>
</div>

<p>Importing <code class="highlighter-rouge">featherbed.circe._</code> brings an implicit derivation from <code class="highlighter-rouge">io.circe.Encoder[A]</code> to
<code class="highlighter-rouge">featherbed.content.Encoder[A, "application/json"]</code>.  As long as there is a Circe <code class="highlighter-rouge">Encoder[A]</code>
in implicit scope, we will be able to pass <code class="highlighter-rouge">A</code> directly as content in featherbed requests:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">io.circe.generic.auto._</span>
<span class="c1">// import io.circe.generic.auto._
</span>
<span class="k">import</span> <span class="nn">featherbed.circe._</span>
<span class="c1">// import featherbed.circe._
</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Foo</span><span class="o">(</span><span class="n">someText</span> <span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">someInt</span> <span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
<span class="c1">// defined class Foo
</span>
<span class="k">val</span> <span class="n">req</span> <span class="k">=</span> <span class="n">client</span><span class="o">.</span><span class="n">post</span><span class="o">(</span><span class="s">"foo/bar"</span><span class="o">).</span><span class="n">withContent</span><span class="o">(</span><span class="nc">Foo</span><span class="o">(</span><span class="s">"Hello world!"</span><span class="o">,</span> <span class="mi">42</span><span class="o">),</span> <span class="s">"application/json"</span><span class="o">)</span>
<span class="c1">// req: featherbed.PostRequest[Foo,String("application/json"),Some[Foo],shapeless.:+:[String("*/*"),shapeless.CNil]] = PostRequest(featherbed.Client@f63b010,localhost:8766,com.twitter.finagle.http.RequestBuilder@5783afd8,Some(Foo(Hello world!,42)),UTF-8)
</span>
<span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="nc">Await</span><span class="o">.</span><span class="n">result</span> <span class="o">{</span>
   <span class="n">req</span> <span class="n">map</span> <span class="o">{</span>
    <span class="n">response</span> <span class="k">=&gt;</span> <span class="n">response</span><span class="o">.</span><span class="n">contentString</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// result: String =
// POST /api/foo/bar :: {
//   "someText" : "Hello world!",
//   "someInt" : 42
// }
</span></code></pre>
</div>

<p>Here we used <code class="highlighter-rouge">io.circe.generic.auto._</code> to automatically derive a JSON codec for <code class="highlighter-rouge">Foo</code> - but if you have need to encode
a particular data type into JSON in a certain way, you can also specify an implicit Circe <code class="highlighter-rouge">Encoder</code> value in the data
type’s companion object.  See the Circe documentation for more details about JSON encoding and decoding.</p>

<h3 id="a-note-about-evaluation">A Note About Evaluation</h3>

<p>You may have noticed that above we created a value called <code class="highlighter-rouge">req</code>, which held the result of specifying the request
type and its parameters.  We later <code class="highlighter-rouge">map</code>ped over that value to specify a transformation of the response.</p>

<p>It’s important to note that the request itself <strong>is not performed</strong> until the call to <code class="highlighter-rouge">map</code> or <code class="highlighter-rouge">flatMap</code>. Until
that call is made, you will have an instance of some kind of request, but you will not have a <code class="highlighter-rouge">Future</code> representing
the response.  That is, the request itself is <em>lazy</em>.  The reason this is important to note is that <code class="highlighter-rouge">req</code> itself can
actually be used to make the same request again.  If another call is made to <code class="highlighter-rouge">req.map</code> or <code class="highlighter-rouge">req.flatMap</code>, a new
request of the same parameters will be initiated and a new <code class="highlighter-rouge">Future</code> will be returned.  This can be a useful and
powerful thing, but it can also bite you if you’re unaware.</p>

<p>For more information about lazy tasks, take a look at scalaz’s <code class="highlighter-rouge">Task</code> or cats’s <code class="highlighter-rouge">Eval</code>.  Again, this is important to
note, and is different than what people are used to with Finagle’s <code class="highlighter-rouge">Future</code> (which is not lazy).</p>

<h3 id="a-note-about-types">A Note About Types</h3>

<p>You may have also noticed that we specified a content type string, <code class="highlighter-rouge">"application/json"</code>.  From this, the request knew
to encode the <code class="highlighter-rouge">Foo</code> object as JSON.  It may not seem obvious, but this decision was actually made <em>at compile time</em>.
When <code class="highlighter-rouge">featherbed.circe._</code> was imported, we gained a typelevel specification that requests being made with
“application/json” can be encoded as long as the payload’s type has an available Circe <code class="highlighter-rouge">Encoder</code>.  This is accomplished
by treating <code class="highlighter-rouge">"application/json"</code> as a value of <em>type</em> <code class="highlighter-rouge">"application/string"</code> rather than a value of type <code class="highlighter-rouge">String</code>. For
more information about singleton literals and their (amazing) implications, check out some of the projects in
Typelevel Scala (particularly Shapeless).  Scala can do some amazing things (but it does need a little help once in a while.)</p>

<p>Next, read about <a href="03-response-decoding-and-validation.html">Response Decoding and Validation</a></p>


      <footer class="site-footer">
  <span class="site-footer-owner"><a href="">featherbed</a> is maintained by <a href="http://jeremyrsmith.github.io">Jeremy Smith</a>.</span>
  <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/pietromenna/jekyll-cayman-theme">Cayman theme</a> by <a href="http://github.com/jasonlong">Jason Long</a>.</span>
</footer>


    </section>

  </body>
</html>
