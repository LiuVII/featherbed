<!DOCTYPE html>
<html lang="en-us">
  
  <head>
  <meta charset="UTF-8">
  <title>featherbed</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <link rel="stylesheet" href="/featherbed/css/normalize.css">
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/featherbed/css/cayman.css">
  <link rel="stylesheet" href="/featherbed/css/code.css">
</head>


  <body>
    <section class="page-header">
  <h1 class="project-name">featherbed</h1>
  <h2 class="project-tagline">Asynchronous Scala HTTP client using Finagle, Shapeless and Cats</h2>
  <a href="https://github.com/jeremyrsmith/featherbed" class="btn">View on GitHub</a>
</section>


    <section class="main-content">
      
      <h1 id="response-decoding-and-validation">Response Decoding and Validation</h1>

<p>In the previous section, we looked at how we can import <code class="highlighter-rouge">Encoder</code> instances to make it so we
can treat case classes as HTTP request content.  We’ve also seen how a request specification
can be <code class="highlighter-rouge">map</code>ped or <code class="highlighter-rouge">flatMap</code>ped over in order to send the request and create a <code class="highlighter-rouge">Future</code> representing
the response.</p>

<p>Once you have a <code class="highlighter-rouge">Future[Response]</code>, what then?  Of course, the <code class="highlighter-rouge">Response</code> will be more useful if
it’s transformed into some typed data.  In a similar fashion to <code class="highlighter-rouge">Encoder</code>, we can make use of
an implicit <code class="highlighter-rouge">Decoder</code> to accomplish this.</p>

<p>First, the setup.  This time, our dummy server is going to be a little more complicated: for
requests to <code class="highlighter-rouge">/foo/good</code>, it will return the same JSON that we give it with an <code class="highlighter-rouge">application/json</code>
Content-Type.  For requests to <code class="highlighter-rouge">/foo/bad</code>, it will return some invalid JSON with an <code class="highlighter-rouge">application/json</code>
Content-Type.  For requests to <code class="highlighter-rouge">/foo/awful</code>, it will return some junk with a completely
unexpected Content-Type.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">com.twitter.util.</span><span class="o">{</span><span class="nc">Future</span><span class="o">,</span><span class="nc">Await</span><span class="o">}</span>
<span class="c1">// import com.twitter.util.{Future, Await}
</span>
<span class="k">import</span> <span class="nn">com.twitter.finagle.</span><span class="o">{</span><span class="nc">Service</span><span class="o">,</span><span class="nc">Http</span><span class="o">}</span>
<span class="c1">// import com.twitter.finagle.{Service, Http}
</span>
<span class="k">import</span> <span class="nn">com.twitter.finagle.http.</span><span class="o">{</span><span class="nc">Request</span><span class="o">,</span><span class="nc">Response</span><span class="o">}</span>
<span class="c1">// import com.twitter.finagle.http.{Request, Response}
</span>
<span class="k">import</span> <span class="nn">java.net.InetSocketAddress</span>
<span class="c1">// import java.net.InetSocketAddress
</span>
<span class="k">val</span> <span class="n">server</span> <span class="k">=</span> <span class="nc">Http</span><span class="o">.</span><span class="n">serve</span><span class="o">(</span><span class="k">new</span> <span class="nc">InetSocketAddress</span><span class="o">(</span><span class="mi">8767</span><span class="o">),</span> <span class="k">new</span> <span class="nc">Service</span><span class="o">[</span><span class="kt">Request</span>, <span class="kt">Response</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">request</span><span class="k">:</span> <span class="kt">Request</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Response</span><span class="o">]</span> <span class="k">=</span> <span class="n">request</span><span class="o">.</span><span class="n">uri</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="s">"/api/foo/good"</span> <span class="k">=&gt;</span> <span class="nc">Future</span> <span class="o">{</span>
        <span class="k">val</span> <span class="n">rep</span> <span class="k">=</span> <span class="nc">Response</span><span class="o">()</span>
        <span class="n">rep</span><span class="o">.</span><span class="n">contentString</span> <span class="k">=</span> <span class="n">request</span><span class="o">.</span><span class="n">contentString</span>
        <span class="n">rep</span><span class="o">.</span><span class="n">setContentTypeJson</span><span class="o">()</span>
        <span class="n">rep</span>
      <span class="o">}</span>
    <span class="k">case</span> <span class="s">"/api/foo/bad"</span> <span class="k">=&gt;</span> <span class="nc">Future</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">rep</span> <span class="k">=</span> <span class="nc">Response</span><span class="o">()</span>
      <span class="n">rep</span><span class="o">.</span><span class="n">contentString</span> <span class="k">=</span> <span class="s">"This text is not valid JSON!"</span>
      <span class="n">rep</span><span class="o">.</span><span class="n">setContentTypeJson</span><span class="o">()</span>
      <span class="n">rep</span>
    <span class="o">}</span>
    <span class="k">case</span> <span class="s">"/api/foo/awful"</span> <span class="k">=&gt;</span> <span class="nc">Future</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">rep</span> <span class="k">=</span> <span class="nc">Response</span><span class="o">()</span>
      <span class="n">rep</span><span class="o">.</span><span class="n">contentString</span> <span class="k">=</span> <span class="s">"This text is not valid anything!"</span>
      <span class="n">rep</span><span class="o">.</span><span class="n">setContentType</span><span class="o">(</span><span class="s">"pie/pumpkin"</span><span class="o">,</span> <span class="s">"UTF-8"</span><span class="o">)</span>
      <span class="n">rep</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">})</span>
<span class="c1">// server: com.twitter.finagle.ListeningServer = Group(/0:0:0:0:0:0:0:0:8767)
</span>
<span class="k">import</span> <span class="nn">java.net.URL</span>
<span class="c1">// import java.net.URL
</span>
<span class="k">val</span> <span class="n">client</span> <span class="k">=</span> <span class="k">new</span> <span class="n">featherbed</span><span class="o">.</span><span class="nc">Client</span><span class="o">(</span><span class="k">new</span> <span class="nc">URL</span><span class="o">(</span><span class="s">"http://localhost:8767/api/"</span><span class="o">))</span>
<span class="c1">// client: featherbed.Client = featherbed.Client@2c41999a
</span></code></pre>
</div>

<p>To specify that a response should be decoded, use the <code class="highlighter-rouge">send[T]</code> method to initiate the request:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">featherbed.circe._</span>
<span class="c1">// import featherbed.circe._
</span>
<span class="k">import</span> <span class="nn">io.circe.generic.auto._</span>
<span class="c1">// import io.circe.generic.auto._
</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Foo</span><span class="o">(</span><span class="n">someText</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">someInt</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
<span class="c1">// defined class Foo
</span>
<span class="nc">Await</span><span class="o">.</span><span class="n">result</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">request</span> <span class="k">=</span> <span class="n">client</span><span class="o">.</span><span class="n">post</span><span class="o">(</span><span class="s">"foo/good"</span><span class="o">)</span>
    <span class="o">.</span><span class="n">withContent</span><span class="o">(</span><span class="nc">Foo</span><span class="o">(</span><span class="s">"Hello world"</span><span class="o">,</span> <span class="mi">42</span><span class="o">),</span> <span class="s">"application/json"</span><span class="o">)</span>

  <span class="n">request</span><span class="o">.</span><span class="n">send</span><span class="o">[</span><span class="kt">Foo</span><span class="o">]()</span>
<span class="o">}</span>
<span class="c1">// &lt;console&gt;:30: error: In order to decode a request to Foo, it must be known that a decoder exists to Foo from all the content types that you Accept, which is currently shapeless.:+:[String("*/*"),shapeless.CNil].
// You may have forgotten to specify Accept types with the `accept[T &lt;: Coproduct]` method, or you may be missing Decoder instances for some content types.
// 
//          request.send[Foo]()
//                           ^
</span></code></pre>
</div>

<p>Oops! What happened? Like the error message explains, we can’t compile that code because we have
to specify an <code class="highlighter-rouge">Accept</code> header and ensure that we’re able to decode all of the types we specify
into <code class="highlighter-rouge">Foo</code>.  In scala type land, the <code class="highlighter-rouge">Accept</code> content types are a <code class="highlighter-rouge">Coproduct</code> of string literals
which can be specified using shapless’s <code class="highlighter-rouge">Coproduct</code> syntax.  In this case, we only want <code class="highlighter-rouge">application/json</code>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">shapeless.Coproduct</span>
<span class="c1">// import shapeless.Coproduct
</span>
<span class="nc">Await</span><span class="o">.</span><span class="n">result</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">request</span> <span class="k">=</span> <span class="n">client</span><span class="o">.</span><span class="n">post</span><span class="o">(</span><span class="s">"foo/good"</span><span class="o">)</span>
    <span class="o">.</span><span class="n">withContent</span><span class="o">(</span><span class="nc">Foo</span><span class="o">(</span><span class="s">"Hello world"</span><span class="o">,</span> <span class="mi">42</span><span class="o">),</span> <span class="s">"application/json"</span><span class="o">)</span>
    <span class="o">.</span><span class="n">accept</span><span class="o">(</span><span class="s">"application/json"</span><span class="o">)</span>

  <span class="n">request</span><span class="o">.</span><span class="n">send</span><span class="o">[</span><span class="kt">Foo</span><span class="o">]()</span>
<span class="o">}</span>
<span class="c1">// res1: cats.data.Validated[featherbed.InvalidResponse,Foo] = Valid(Foo(Hello world,42))
</span></code></pre>
</div>

<p>Look at that!  The JSON that came back was automatically decoded into a <code class="highlighter-rouge">Foo</code>!  But what’s that <code class="highlighter-rouge">Valid</code>
thing around it?  As we’re about to see, when you’re interacting with a server, you can’t be sure that
you’ll get what you expect.  The server might send malformed JSON, or might not send JSON at all. To
handle this in an idiomatic way, <code class="highlighter-rouge">send[Foo]()</code> actually returns a <code class="highlighter-rouge">Future[Validated[InvalidResponse, Foo]]</code>.
What this means is that the result of the <code class="highlighter-rouge">Future</code> will be a <code class="highlighter-rouge">cats.data.Validated</code>, which will be either
<code class="highlighter-rouge">Valid(Foo(...))</code> or <code class="highlighter-rouge">Invalid(InvalidResponse)</code>.  The <code class="highlighter-rouge">InvalidResponse</code> contains a message about why the
response was invalid, as well as the <code class="highlighter-rouge">Response</code> itself (so you can process it further if you like).
Let’s see what that looks like:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="nc">Await</span><span class="o">.</span><span class="n">result</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">request</span> <span class="k">=</span> <span class="n">client</span><span class="o">.</span><span class="n">post</span><span class="o">(</span><span class="s">"foo/bad"</span><span class="o">)</span>
    <span class="o">.</span><span class="n">withContent</span><span class="o">(</span><span class="nc">Foo</span><span class="o">(</span><span class="s">"Hello world"</span><span class="o">,</span> <span class="mi">42</span><span class="o">),</span> <span class="s">"application/json"</span><span class="o">)</span>
    <span class="o">.</span><span class="n">accept</span><span class="o">[</span><span class="kt">Coproduct.`</span><span class="err">"</span><span class="kt">application/json</span><span class="err">"</span><span class="kt">`.T</span><span class="o">]</span>

  <span class="n">request</span><span class="o">.</span><span class="n">send</span><span class="o">[</span><span class="kt">Foo</span><span class="o">]()</span>
<span class="o">}</span>
<span class="c1">// res2: cats.data.Validated[featherbed.InvalidResponse,Foo] = Invalid(InvalidResponse(Response("HTTP/1.1 Status(200)"),expected json value got T (line 1, column 1)))
</span>
<span class="nc">Await</span><span class="o">.</span><span class="n">result</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">request</span> <span class="k">=</span> <span class="n">client</span><span class="o">.</span><span class="n">post</span><span class="o">(</span><span class="s">"foo/awful"</span><span class="o">)</span>
    <span class="o">.</span><span class="n">withContent</span><span class="o">(</span><span class="nc">Foo</span><span class="o">(</span><span class="s">"Hello world"</span><span class="o">,</span> <span class="mi">42</span><span class="o">),</span> <span class="s">"application/json"</span><span class="o">)</span>
    <span class="o">.</span><span class="n">accept</span><span class="o">[</span><span class="kt">Coproduct.`</span><span class="err">"</span><span class="kt">application/json</span><span class="err">"</span><span class="kt">`.T</span><span class="o">]</span>

  <span class="n">request</span><span class="o">.</span><span class="n">send</span><span class="o">[</span><span class="kt">Foo</span><span class="o">]()</span>
<span class="o">}</span>
<span class="c1">// res3: cats.data.Validated[featherbed.InvalidResponse,Foo] = Invalid(InvalidResponse(Response("HTTP/1.1 Status(200)"),No decoder was found for pie/pumpkin))
</span></code></pre>
</div>

<p>As you can see, these different failure scenarios provide different messages about what failure occured,
and give the original <code class="highlighter-rouge">Response</code>.  In the first case, we get back Circe’s parsing error.  In the second
case, we get a message that the content type wasn’t expected and therefore there isn’t a decoder for it.
This helps us deal with inevitable runtime failures resulting from external systems.</p>

<p>Next, read about <a href="04-building-rest-clients.html">Building REST Clients</a></p>


      <footer class="site-footer">
  <span class="site-footer-owner"><a href="">featherbed</a> is maintained by <a href="http://jeremyrsmith.github.io">Jeremy Smith</a>.</span>
  <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/pietromenna/jekyll-cayman-theme">Cayman theme</a> by <a href="http://github.com/jasonlong">Jason Long</a>.</span>
</footer>


    </section>

  </body>
</html>
